#!/usr/bin/perl -w
# Convert Packages.gz files into Sleepycat db files for efficient usage of
# data
#
# $Id$
#
# Copyright (C) 2006  Jeroen van Wolffelaar <jeroen@wolffelaar.nl>
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

use strict;
use lib './lib';

$| = 1;

my $what = $ARGV[0] ? "non-free" : "*";
# max. distinct results for a given package postfix
my $MAX_PACKAGE_POSTFIXES = 100;

use DB_File;
use Storable;
use Packages::Config qw( $TOPDIR $DBDIR @ARCHIVES @SUITES );
&Packages::Config::init( './' );
my %packages_small = ();
my %package_names = ();
my %package_postfixes = ();
my %sources_packages = ();
my %descriptions = ();
my @descriptions = ("we count lines one-based\000");
my %packages_descriptions = ();
my %descriptions_packages = ();

my %sections = ();
my %subsections = ();
my %priorities = ();

$/ = "";

for my $archive (@ARCHIVES) {
    for my $suite (@SUITES) {

	my %virtual_packages = ();
	print "Reading $archive/$suite...\n";
	my %packages_all_db;
	tie %packages_all_db, "DB_File", "$DBDIR/packages_all_$suite.db.new",
		O_RDWR|O_CREAT, 0666, $DB_BTREE
		or die "Error creating DB: $!";
	open PKG, "zcat $TOPDIR/archive/$archive/$suite/$what/{,debian-installer/}binary-*/Packages.gz|";
	while (<PKG>) {
		next if /^\s*$/;
		my $data = "";
		my %data = ();
		chomp;
		s/\n /\377/g;
		while (/^(\S+):\s*(.*)\s*$/mg) {
			my ($key, $value) = ($1, $2);
			$value =~ s/\377/\n /g;
			$key =~ tr [A-Z] [a-z];
			$data{$key} = $value;
		}
		# Skip double package
		next if exists($packages_all_db{"$data{'package'} $data{'architecture'} $data{'version'}"});

		if ($data{'provides'}) {
		    foreach (split /\s*,\s*/, $data{'provides'}) {
			$virtual_packages{$_}{$data{'package'}}++;
		    }
		}
		$package_names{$data{'package'}} = 1;
		my $src = $data{'package'};
		my $src_version = '';
		if ($data{'source'}) {
			$src = $data{'source'};
			$src =~ s/\s+.*//; # strip version info
		}
		$data{'source'} = $src;
		my $descr = $data{'description'};
		my $did = undef;
		if (exists($descriptions{$descr})) {
			$did  = $descriptions{$descr};
		} else {
			$did = 1 + $#descriptions;
			$descriptions[$did] = $descr;
			$descriptions{$descr} = $did;
		}
		$data{'description'} = $did;
		$packages_descriptions{"$data{'package'} $data{'version'} $data{'architecture'}"} = $did;
		$descriptions_packages{$did} .=
			"$data{'package'} $data{'version'} $data{'architecture'}\000";

		my $sdescr = $descr;
		$sdescr =~ s/\n.*//s;
		my $section = 'main';
		my $subsection = $data{section} || '-';
		if ($data{section} && ($data{section} =~ m=/=o)) {
		    ($section, $subsection) = split m=/=o, $data{section}, 2;
		    ($subsection, $section) = split m=/=o, $data{section}, 2
			if $section eq 'non-US';
		}
		$data{'section'} = $section;
		$data{'subsection'} = $subsection;
		$data{'priority'} ||= '-';
		$sections{$suite}{$archive}{$section}++;
		$subsections{$suite}{$archive}{$subsection}++;
		$priorities{$suite}{$archive}{$data{priority}}++;
		$packages_small{$data{'package'}} .= "$archive $suite $data{'architecture'} ".
			"$section $subsection $data{'priority'} $data{'version'} $sdescr\000";
		$sources_packages{$src} .=
			"$archive $suite $data{'package'} $data{'version'} $data{'architecture'}\000";
		$data{archive} = $archive;
		while (my ($key, $value) = each (%data)) {
			next if $key eq 'package' or $key eq 'version' or $key eq 'architecture'
				or $key eq 'maintainer';
			print STDERR "WARN: $key ($suite/$archive/$data{package}/$data{architecture}\n" unless defined $value;
			$data .= "$key\00$value\00";
		}
		$data =~ s/.$//s;
		$packages_all_db{"$data{'package'} $data{'architecture'} $data{'version'}"}
			= $data;
	}

	foreach (keys %virtual_packages) {
	    my @provided_by = keys %{$virtual_packages{$_}};
	    $packages_small{$_} .= "$archive $suite virtual v v v v @provided_by\000";
	}

	untie %packages_all_db;
    }
}

print "Writing databases...\n";
my %packages_small_db;
tie %packages_small_db, "DB_File", "$DBDIR/packages_small.db.new",
	O_RDWR|O_CREAT, 0666, $DB_BTREE
	or die "Error creating DB: $!";
while (my ($k, $v) = each(%packages_small)) {
	$v =~ s/.$//s;
	$packages_small_db{$k} = $v;
}
untie %packages_small_db;

my %sources_packages_db;
tie %sources_packages_db, "DB_File", "$DBDIR/sources_packages.db.new",
	O_RDWR|O_CREAT, 0666, $DB_BTREE
	or die "Error creating DB: $!";
while (my ($k, $v) = each(%sources_packages)) {
	$v =~ s/.$//s;
	$sources_packages_db{$k} = $v;
}
untie %sources_packages_db;

my %packages_descriptions_db;
tie %packages_descriptions_db, "DB_File", "$DBDIR/packages_descriptions.db.new",
	O_RDWR|O_CREAT, 0666, $DB_BTREE
	or die "Error creating DB: $!";
while (my ($k, $v) = each(%packages_descriptions)) {
	$packages_descriptions_db{$k} = $v;
}
untie %packages_descriptions_db;

my %descriptions_packages_db;
tie %descriptions_packages_db, "DB_File", "$DBDIR/descriptions_packages.db.new",
	O_RDWR|O_CREAT, 0666, $DB_BTREE
	or die "Error creating DB: $!";
while (my ($k, $v) = each(%descriptions_packages)) {
	$v =~ s/.$//s;
	$descriptions_packages_db{$k} = $v;
}
untie %descriptions_packages_db;

my %descriptions_db;
tie %descriptions_db, "DB_File", "$DBDIR/descriptions.db.new",
	O_RDWR|O_CREAT, 0666, $DB_BTREE
	or die "Error creating DB: $!";
open DESCR, ">", "$DBDIR/descriptions.txt" or die "Error creating descriptions textfile";
for (my $i=1; $i<= $#descriptions; $i++) {
	my $plain_description = $descriptions[$i];
# WARNING: This needs to correspond with what happens in
# Packages/Search.pm:do_fulltext_search
	$plain_description =~ tr [A-Z] [a-z];
	# ensure one space on both ends
	$plain_description = " $plain_description ";
	$plain_description =~ s/[(),.-]+//og;
	$plain_description =~ s#[^a-z0-9_/+]+# #og;
	print DESCR "$plain_description\n";
	$descriptions_db{$i} = $descriptions[$i];
}
close DESCR;
untie %descriptions_db;

# package names stuff:
for my $pkg (keys %package_names) {
	for (my $i=0;$i<length($pkg)-1;$i++) {
		my $before = substr($pkg, 0, $i);
		my $after = substr($pkg, $i);
		$before = "^" if $before eq ""; # otherwise split doesn't work properly
		$package_postfixes{$after} .= "$before\0";
	}
}
my %package_postfixes_db;
tie %package_postfixes_db, "DB_File", "$DBDIR/package_postfixes.db.new",
	O_RDWR|O_CREAT, 0666, $DB_BTREE
	or die "Error creating DB: $!";
while (my ($k, $v) = each(%package_postfixes)) {
	$v =~ s/.$//s;
	my $nr = $v;
	$nr =~ s/[^\000]//g;
	$nr = length($nr) + 1; # < number of hits
	if ($nr > $MAX_PACKAGE_POSTFIXES) {
		$v = "\001" . $nr;
	}
	$package_postfixes_db{$k} = $v;
}
untie %package_postfixes_db;

store \%sections, "$DBDIR/sections.info";
store \%subsections, "$DBDIR/subsections.info";
store \%priorities, "$DBDIR/priorities.info";

rename("$DBDIR/packages_small.db.new", "$DBDIR/packages_small.db");
rename("$DBDIR/sources_packages.db.new", "$DBDIR/sources_packages.db");
for my $suite (@SUITES) {
	rename("$DBDIR/packages_all_$suite.db.new",
	       "$DBDIR/packages_all_$suite.db");
}
rename("$DBDIR/packages_descriptions.db.new",
       "$DBDIR/packages_descriptions.db");
rename("$DBDIR/descriptions_packages.db.new",
       "$DBDIR/descriptions_packages.db");
rename("$DBDIR/descriptions.txt.new", "$DBDIR/descriptions.txt");
rename("$DBDIR/descriptions.db.new", "$DBDIR/descriptions.db");
rename("$DBDIR/package_postfixes.db.new", "$DBDIR/package_postfixes.db");
