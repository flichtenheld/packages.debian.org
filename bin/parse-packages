#!/usr/bin/perl -w
# Convert Packages.gz files into Sleepycat db files for efficient usage of
# data
#
# $Id$
#
# Copyright (C) 2006  Jeroen van Wolffelaar <jeroen@wolffelaar.nl>
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

use strict;

my $what = $ARGV[0] ? "non-free" : "*";
# max. distinct results for a given package postfix
my $MAX_PACKAGE_POSTFIXES = 100;

use DB_File;
my %packages_small = ();
my %package_names = ();
my %package_postfixes = ();
my %sources_packages = ();
my %descriptions = ();
my @descriptions = ("we count lines one-based\000");
my %packages_descriptions = ();
my %descriptions_packages = ();

my @archives = ( 'us', 'non-US', 'security', 'volatile', 'backports' );
my @suites = ('oldstable', 'stable', 'testing', 'unstable', 'experimental');

$/ = "";

for my $archive (@archives) {
    for my $suite (@suites) {

	print "Reading $archive/$suite...\n";
	my %packages_all_db;
	tie %packages_all_db, "DB_File", "packages_all_$suite.db.new",
		O_RDWR|O_CREAT, 0666, $DB_BTREE
		or die "Error creating DB: $!";
	open PKG, "zcat /org/packages.debian.org/archive/$archive/$suite/$what/{,debian-installer/}binary-*/Packages.gz|";
	while (<PKG>) {
		next if /^\s*$/;
		my $data = "";
		my %data = ();
		chomp;
		s/\n /\377/g;
		while (/^(\S+):\s*(.*)\s*$/mg) {
			my ($key, $value) = ($1, $2);
			$value =~ s/\377/\n /g;
			$key =~ tr [A-Z] [a-z];
			$data{$key} = $value;
		}
		# Skip double package
		next if exists($packages_all_db{"$data{'package'} $data{'architecture'} $data{'version'}"});

		$package_names{$data{'package'}} = 1;
		my $src = $data{'package'};
		my $src_version = '';
		if ($data{'source'}) {
			$src = $data{'source'};
			$src_version = $1
			    if $src =~ s/\s+\(\s*=\s*(.*)\).*//; # strip version info
		}
		$data{'source'} = $src;
		$data{'source-version'} = $src_version;
		my $descr = $data{'description'};
		my $did = undef;
		if (exists($descriptions{$descr})) {
			$did  = $descriptions{$descr};
		} else {
			$did = 1 + $#descriptions;
			$descriptions[$did] = $descr;
			$descriptions{$descr} = $did;
		}
		$data{'description'} = $did;
		$packages_descriptions{"$data{'package'} $data{'version'} $data{'architecture'}"} = $did;
		$descriptions_packages{$did} .=
			"$data{'package'} $data{'version'} $data{'architecture'}\000";

		my $sdescr = $descr;
		$sdescr =~ s/\n.*//s;
		my $section = 'main';
		my $subsection = $data{section} || '-';
		if ($data{section} && ($data{section} =~ m=/=o)) {
		    ($section, $subsection) = split m=/=o, $data{section}, 2;
		}
		$data{'section'} = $section;
		$data{'subsection'} = $subsection;
		$data{'priority'} ||= '-';
		$packages_small{$data{'package'}} .= "$archive $suite $data{'architecture'} ".
			"$section $subsection $data{'priority'} $data{'version'} $sdescr\000";
		$sources_packages{$src} .=
			"$archive $suite $data{'package'} $data{'version'} $data{'architecture'}\000";
		$data{archive} = $archive;
		while (my ($key, $value) = each (%data)) {
			next if $key eq 'package' or $key eq 'version' or $key eq 'architecture'
				or $key eq 'maintainer';
			print STDERR "WARN: $key ($suite/$archive/$data{package}/$data{architecture}\n" unless defined $value;
			$data .= "$key: $value\n";
		}
		$packages_all_db{"$data{'package'} $data{'architecture'} $data{'version'}"}
			= $data;
	}

	untie %packages_all_db;
    }
}

print "Writing databases...\n";
my %packages_small_db;
tie %packages_small_db, "DB_File", "packages_small.db.new",
	O_RDWR|O_CREAT, 0666, $DB_BTREE
	or die "Error creating DB: $!";
while (my ($k, $v) = each(%packages_small)) {
	$v =~ s/.$//s;
	$packages_small_db{$k} = $v;
}
untie %packages_small_db;

my %sources_packages_db;
tie %sources_packages_db, "DB_File", "sources_packages.db.new",
	O_RDWR|O_CREAT, 0666, $DB_BTREE
	or die "Error creating DB: $!";
while (my ($k, $v) = each(%sources_packages)) {
	$v =~ s/.$//s;
	$sources_packages_db{$k} = $v;
}
untie %sources_packages_db;

my %packages_descriptions_db;
tie %packages_descriptions_db, "DB_File", "packages_descriptions.db.new",
	O_RDWR|O_CREAT, 0666, $DB_BTREE
	or die "Error creating DB: $!";
while (my ($k, $v) = each(%packages_descriptions)) {
	$packages_descriptions_db{$k} = $v;
}
untie %packages_descriptions_db;

my %descriptions_packages_db;
tie %descriptions_packages_db, "DB_File", "descriptions_packages.db.new",
	O_RDWR|O_CREAT, 0666, $DB_BTREE
	or die "Error creating DB: $!";
while (my ($k, $v) = each(%descriptions_packages)) {
	$v =~ s/.$//s;
	$descriptions_packages_db{$k} = $v;
}
untie %descriptions_packages_db;

my %descriptions_db;
tie %descriptions_db, "DB_File", "descriptions.db.new",
	O_RDWR|O_CREAT, 0666, $DB_BTREE
	or die "Error creating DB: $!";
open DESCR, "> descriptions.txt" or die "Error creating descriptions textfile";
for (my $i=1; $i<= $#descriptions; $i++) {
	my $plain_description = $descriptions[$i];
	$plain_description =~ s/\n .\n/ /og;
	$plain_description =~ s/[\n \t]+/ /og;
	print DESCR "$plain_description\n";
	$descriptions_db{$i} = $descriptions[$i];
}
close DESCR;
untie %descriptions_db;

# package names stuff:
for my $pkg (keys %package_names) {
	for (my $i=0;$i<length($pkg)-1;$i++) {
		my $before = substr($pkg, 0, $i);
		my $after = substr($pkg, $i);
		$before = "^" if $before eq ""; # otherwise split doesn't work properly
		$package_postfixes{$after} .= "$before\0";
	}
}
my %package_postfixes_db;
tie %package_postfixes_db, "DB_File", "package_postfixes.db.new",
	O_RDWR|O_CREAT, 0666, $DB_BTREE
	or die "Error creating DB: $!";
while (my ($k, $v) = each(%package_postfixes)) {
	$v =~ s/.$//s;
	my $nr = $v;
	$nr =~ s/[^\000]//g;
	$nr = length($nr) + 1; # < number of hits
	if ($nr > $MAX_PACKAGE_POSTFIXES) {
		$v = "\001" . $nr;
	}
	$package_postfixes_db{$k} = $v;
}
untie %package_postfixes_db;

rename("packages_small.db.new", "packages_small.db");
rename("sources_packages.db.new", "sources_packages.db");
for my $suite (@suites) {
	rename("packages_all_$suite.db.new", "packages_all_$suite.db");
}
rename("packages_descriptions.db.new", "packages_descriptions.db");
rename("descriptions_packages.db.new", "descriptions_packages.db");
rename("descriptions.txt.new", "descriptions.txt");
rename("descriptions.db.new", "descriptions.db");
rename("package_postfixes.db.new", "package_postfixes.db");
