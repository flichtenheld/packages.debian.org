#!/usr/bin/perl -w
# Convert Sources.gz files into Sleepycat db files for efficient usage of
# data
#
# $Id$
#
# Copyright (C) 2006  Jeroen van Wolffelaar <jeroen@wolffelaar.nl>
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

use strict;

my $what = $ARGV[0] ? "non-free" : "*";
# max. distinct results for a given package postfix
my $MAX_SOURCE_POSTFIXES = 100;

use DB_File;
my %sources_small = ();
my %source_names = ();
my %source_postfixes = ();

my @archives = ( 'us', 'non-US', 'security', 'volatile', 'backports' );
my @suites = ('oldstable', 'stable', 'testing', 'unstable', 'experimental');

$/ = "";

for my $archive (@archives) {
    for my $suite (@suites) {

	print "Reading $archive/$suite...\n";
	my %sources_all_db;
	tie %sources_all_db, "DB_File", "sources_all_$suite.db.new",
		O_RDWR|O_CREAT, 0666, $DB_BTREE
		or die "Error creating DB: $!";
	open PKG, "zcat /org/packages.debian.org/archive/$archive/$suite/$what/source/Sources.gz|";
	while (<PKG>) {
		next if /^\s*$/;
		my $data = "";
		my %data = ();
		chomp;
		s/\n /\377/g;
		while (/^(\S+):\s*(.*)\s*$/mg) {
			my ($key, $value) = ($1, $2);
			$value =~ s/\377/\n /g;
			$data .= "$key: $value\n";
			$key =~ tr [A-Z] [a-z];
			$data{$key} = $value;
		}
		$data .= "Archive: $archive\n";
		$sources_all_db{"$data{'package'} $data{'version'}"}
			= $data;

		$source_names{$data{'package'}} = 1;

		my $section = 'main';
		my $subsection = $data{section} || '-';
		if ($data{section} && ($data{section} =~ m=/=o)) {
		    ($section, $subsection) = split m=/=o, $data{section}, 2;
		}
		$data{'priority'} = "-" if not exists($data{'priority'});
		$sources_small{$data{'package'}} .=
			"$archive $suite $section $subsection $data{'priority'} $data{'version'}\000";
	}

	untie %sources_all_db;
    }
}

print "Writing databases...\n";
my %sources_small_db;
tie %sources_small_db, "DB_File", "sources_small.db.new",
	O_RDWR|O_CREAT, 0666, $DB_BTREE
	or die "Error creating DB: $!";
while (my ($k, $v) = each(%sources_small)) {
	$v =~ s/.$//s;
	$sources_small_db{$k} = $v;
}
untie %sources_small_db;

# package names stuff:
for my $pkg (keys %source_names) {
	for (my $i=0;$i<length($pkg)-1;$i++) {
		my $before = substr($pkg, 0, $i);
		my $after = substr($pkg, $i);
		$before = "^" if $before eq ""; # otherwise split doesn't work properly
		$source_postfixes{$after} .= "$before\0";
	}
}
my %source_postfixes_db;
tie %source_postfixes_db, "DB_File", "source_postfixes.db.new",
	O_RDWR|O_CREAT, 0666, $DB_BTREE
	or die "Error creating DB: $!";
while (my ($k, $v) = each(%source_postfixes)) {
	$v =~ s/.$//s;
	my $nr = $v;
	$nr =~ s/[^\000]//g;
	$nr = length($nr) + 1; # < number of hits
	if ($nr > $MAX_SOURCE_POSTFIXES) {
		$v = "\001" . $nr;
	}
	$source_postfixes_db{$k} = $v;
}
untie %source_postfixes_db;

for my $suite (@suites) {
	rename("sources_all_$suite.db.new", "sources_all_$suite.db");
}
rename("sources_small.db.new", "sources_small.db");
rename("source_postfixes.db.new", "source_postfixes.db");
